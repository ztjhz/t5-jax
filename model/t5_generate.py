import jax
import jax.numpy as jnp

from model.t5 import fwd_t5
from config import config


@jax.jit
def fwd_t5_generate(
    params: dict,
    encoder_input_ids: jnp.ndarray,
    eos_token_id: int = 1,
    decoder_start_token_id: int = 0,
    tie_word_embeddings: bool = True,
) -> jnp.ndarray:
    """
    Generates a sequence using the fwd_t5.

    Args:
        params (dict): A dictionary of model parameters.

        encoder_input_ids (jnp.ndarray): Input IDs for the encoder.

        eos_token_id (int, optional): ID of the end-of-sequence token. Defaults to 1.

        decoder_start_token_id (int, optional): ID of the start-of-sequence token for the decoder. Defaults to 0.

        tie_word_embeddings (bool, optional): Whether to use tie word embeddings for the language model head. Defaults to True.

    Returns:
        jnp.ndarray: Sequence generated by the T5 model. (batch_size, sequence_length)

    """

    def generation_step(carry, _):
        """
        Args:
            carry (tuple [pos, is_complete, encoder_output, decoder_input_ids]):
                pos (int): The position of the decoder output to take.

                is_complete (jnp.ndarray): Whether each sequence have reached EOS of shape (batch_size, 1).

                encoder_output (Optional[jnp.ndarray]): The cached encoder output. In this case, encoder output is always None
                    as `jax.lax.scan` requires the "scanned function carry input and carry output must have the same pytree structure".

                decoder_input_ids (jnp.ndarray): The output ids of the decoder of shape (batch_size, max_generation_sequence_length).

        Returns:
            tuple[carry, _]: The updated carry is returned.
        """

        def skip(carry):
            """
            All sequences have reached EOS, return same output.
            """
            return carry

        def generate_next_token(carry):
            """
            Generate the next token in the sequence.
            """
            pos, is_complete, encoder_output, decoder_input_ids = carry

            # logits shape: (batch_size, decoder_sequence_length, vocab_size)
            logits, encoder_output = fwd_t5(
                params=params,
                encoder_input_ids=encoder_input_ids,
                decoder_input_ids=decoder_input_ids,
                tie_word_embeddings=tie_word_embeddings,
                encoder_output=encoder_output,
            )

            # compute the token for all logits of the decoder sequence output
            # token shape: (batch_size, decoder_sequence_length)
            token = jnp.argmax(logits, axis=-1)

            # only keep the current position token of each decoder sequence output
            # token shape: (batch_size,)
            token = token[..., pos]

            # reshape to (batch_size, 1)
            token = token[:, None]

            # convert token of completed sequence to pad
            token = token * ~is_complete + config.PAD_TOKEN_ID * is_complete

            # update whether a sequence has reached EOS
            is_complete = is_complete | token == eos_token_id

            # add current position token output to the decoder_input_ids at the next position
            pos += 1
            decoder_input_ids = decoder_input_ids.at[..., pos].set(token.flatten())

            # return encoder output as None because: "scanned function carry input and carry output must have the same pytree structure"
            return pos, is_complete, None, decoder_input_ids

        new_carry = jax.lax.cond(jnp.all(is_complete), skip, generate_next_token, carry)
        return new_carry, None

    # Initialization
    encoder_output = None
    # initialise decoder_input_ids to shape of (batch_size, max_generation_sequence_length)
    # shape of (batch_size, 1) is not used as decoder_input_ids shape is not constant during generation but jax.lax requires input and output carry to have the constant dimension
    decoder_input_ids = (
        jnp.ones((encoder_input_ids.shape[0], config.MAX_GENERATION_LENGTH), dtype="i4")
        * config.PAD_TOKEN_ID
    )
    # set the first id of each sequence to BOS
    decoder_input_ids = decoder_input_ids.at[..., 0].set(decoder_start_token_id)

    # to keep track of whether a sequence has reached EOS (batch_size, 1)
    is_complete = jnp.zeros((encoder_input_ids.shape[0], 1), dtype=jnp.bool_)

    # initialise carry state
    init_carry = (0, is_complete, encoder_output, decoder_input_ids)

    final_carry, _ = jax.lax.scan(
        generation_step,
        init_carry,
        jnp.arange(config.MAX_GENERATION_LENGTH),
    )

    final_decoder_input_ids = final_carry[3]
    return final_decoder_input_ids
